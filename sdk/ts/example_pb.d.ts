/* eslint-disable */
/*Generated by GenDocu.com*/
// package: v1
// file: example.proto

import * as jspb from "google-protobuf";

export class ExampleMessage1 extends jspb.Message {
  getMystring(): string;
  setMystring(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ExampleMessage1.AsObject;
  static toObject(includeInstance: boolean, msg: ExampleMessage1): ExampleMessage1.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ExampleMessage1, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ExampleMessage1;
  static deserializeBinaryFromReader(message: ExampleMessage1, reader: jspb.BinaryReader): ExampleMessage1;
}

export namespace ExampleMessage1 {
  export type AsObject = {
    mystring: string,
  }
}

export class ExampleMessage2 extends jspb.Message {
  getMyint(): number;
  setMyint(value: number): void;

  hasNested(): boolean;
  clearNested(): void;
  getNested(): ExampleMessage2.ExampleNested | undefined;
  setNested(value?: ExampleMessage2.ExampleNested): void;

  getAliased(): ExampleMessage2.EnumAllowingAliasMap[keyof ExampleMessage2.EnumAllowingAliasMap];
  setAliased(value: ExampleMessage2.EnumAllowingAliasMap[keyof ExampleMessage2.EnumAllowingAliasMap]): void;

  getAliased2(): ExampleMessage2.EnumAllowingAlias2Map[keyof ExampleMessage2.EnumAllowingAlias2Map];
  setAliased2(value: ExampleMessage2.EnumAllowingAlias2Map[keyof ExampleMessage2.EnumAllowingAlias2Map]): void;

  getGlobalEnum(): GlobalEnum1Map[keyof GlobalEnum1Map];
  setGlobalEnum(value: GlobalEnum1Map[keyof GlobalEnum1Map]): void;

  clearRepeatedGlobalEnumList(): void;
  getRepeatedGlobalEnumList(): Array<GlobalEnum1Map[keyof GlobalEnum1Map]>;
  setRepeatedGlobalEnumList(value: Array<GlobalEnum1Map[keyof GlobalEnum1Map]>): void;
  addRepeatedGlobalEnum(value: GlobalEnum1Map[keyof GlobalEnum1Map], index?: number): GlobalEnum1Map[keyof GlobalEnum1Map];

  hasOptionalGlobalEnum(): boolean;
  clearOptionalGlobalEnum(): void;
  getOptionalGlobalEnum(): GlobalEnum1Map[keyof GlobalEnum1Map];
  setOptionalGlobalEnum(value: GlobalEnum1Map[keyof GlobalEnum1Map]): void;

  hasNestedMessage(): boolean;
  clearNestedMessage(): void;
  getNestedMessage(): ExampleMessage2.NestedMessage | undefined;
  setNestedMessage(value?: ExampleMessage2.NestedMessage): void;

  getNestedNestedEnum(): ExampleMessage2.NestedMessage.NestedNestedEnumMap[keyof ExampleMessage2.NestedMessage.NestedNestedEnumMap];
  setNestedNestedEnum(value: ExampleMessage2.NestedMessage.NestedNestedEnumMap[keyof ExampleMessage2.NestedMessage.NestedNestedEnumMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ExampleMessage2.AsObject;
  static toObject(includeInstance: boolean, msg: ExampleMessage2): ExampleMessage2.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ExampleMessage2, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ExampleMessage2;
  static deserializeBinaryFromReader(message: ExampleMessage2, reader: jspb.BinaryReader): ExampleMessage2;
}

export namespace ExampleMessage2 {
  export type AsObject = {
    myint: number,
    nested?: ExampleMessage2.ExampleNested.AsObject,
    aliased: ExampleMessage2.EnumAllowingAliasMap[keyof ExampleMessage2.EnumAllowingAliasMap],
    aliased2: ExampleMessage2.EnumAllowingAlias2Map[keyof ExampleMessage2.EnumAllowingAlias2Map],
    globalEnum: GlobalEnum1Map[keyof GlobalEnum1Map],
    repeatedGlobalEnumList: Array<GlobalEnum1Map[keyof GlobalEnum1Map]>,
    optionalGlobalEnum: GlobalEnum1Map[keyof GlobalEnum1Map],
    nestedMessage?: ExampleMessage2.NestedMessage.AsObject,
    nestedNestedEnum: ExampleMessage2.NestedMessage.NestedNestedEnumMap[keyof ExampleMessage2.NestedMessage.NestedNestedEnumMap],
  }

  export class NestedMessage extends jspb.Message {
    getV(): ExampleMessage2.NestedMessage.NestedNestedEnumMap[keyof ExampleMessage2.NestedMessage.NestedNestedEnumMap];
    setV(value: ExampleMessage2.NestedMessage.NestedNestedEnumMap[keyof ExampleMessage2.NestedMessage.NestedNestedEnumMap]): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): NestedMessage.AsObject;
    static toObject(includeInstance: boolean, msg: NestedMessage): NestedMessage.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: NestedMessage, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): NestedMessage;
    static deserializeBinaryFromReader(message: NestedMessage, reader: jspb.BinaryReader): NestedMessage;
  }

  export namespace NestedMessage {
    export type AsObject = {
      v: ExampleMessage2.NestedMessage.NestedNestedEnumMap[keyof ExampleMessage2.NestedMessage.NestedNestedEnumMap],
    }

    export interface NestedNestedEnumMap {
      NESTEDNESTEDVALUE: 0;
      NESTEDNESTEDVALUE1: 1;
    }

    export const NestedNestedEnum: NestedNestedEnumMap;
  }

  export class ExampleNested extends jspb.Message {
    getData(): Uint8Array | string;
    getData_asU8(): Uint8Array;
    getData_asB64(): string;
    setData(value: Uint8Array | string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ExampleNested.AsObject;
    static toObject(includeInstance: boolean, msg: ExampleNested): ExampleNested.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: ExampleNested, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ExampleNested;
    static deserializeBinaryFromReader(message: ExampleNested, reader: jspb.BinaryReader): ExampleNested;
  }

  export namespace ExampleNested {
    export type AsObject = {
      data: Uint8Array | string,
    }
  }

  export interface EnumAllowingAliasMap {
    UNKNOWN: 0;
    STARTED: 1;
    RUNNING: 1;
  }

  export const EnumAllowingAlias: EnumAllowingAliasMap;

  export interface EnumAllowingAlias2Map {
    UNKNOWN2: 0;
    STARTED2: 1;
  }

  export const EnumAllowingAlias2: EnumAllowingAlias2Map;
}

export class ReturnType extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ReturnType.AsObject;
  static toObject(includeInstance: boolean, msg: ReturnType): ReturnType.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ReturnType, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ReturnType;
  static deserializeBinaryFromReader(message: ReturnType, reader: jspb.BinaryReader): ReturnType;
}

export namespace ReturnType {
  export type AsObject = {
  }
}

export interface GlobalEnum1Map {
  GLOBALENUMVAL: 0;
  GLOBALENUMVAL1: 1;
  GLOBALENUMVAL11: 1;
  GLOBALENUMVAL12: 1;
  GLOBALENUMVAL2: 2;
  GLOBALENUMVAL3: 3;
}

export const GlobalEnum1: GlobalEnum1Map;

